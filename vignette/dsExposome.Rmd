---
title: "Non-disclosive federated exposome data analysis with DataSHIELD and Bioconductor"
author:
- name: Xavier Escribà Montagut
  affiliation:
  - &isglobal Bioinformatics Research Group in Epidemiolgy (BRGE), Barcelona Insitute for Global Health (ISGlobal)
  email: xavier.escriba@isglobal.org
- name: Juan R. Gonzalez
  affiliation:
  - &isglobal Bioinformatics Research Group in Epidemiolgy (BRGE), Barcelona Insitute for Global Health (ISGlobal)
  email: juanr.gonzalez@isglobal.org
date: "`r Sys.Date()`"
package: "`r pkg_ver('dsExposome')`, `r pkg_ver('dsExposomeClient')`"
output:
  BiocStyle::html_document
bibliography: dsExposome_Vignette.bib
vignette: >
  %\VignetteIndexEntry{Non-disclosive federated exposome data analysis with DataSHIELD and Bioconductor}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
BiocStyle::markdown()
options(width=80)
knitr::opts_chunk$set(comment="", warning=FALSE, message=FALSE, cache=FALSE)
```

# Purpose

# Setup

# Exposome analysis

## Connecting to the Opal server



## Loading the Exposome Set

An exposome dataset is made up from [three different tables](https://www.bioconductor.org/packages/release/bioc/vignettes/rexposome/inst/doc/exposome_data_analysis.html#data-format). In order to be studied, this three tables need to be coerced into a R object of class `ExposomeSet`, for that reason an exposome dataset can be available on a server as three tables or as a resource.

### From tables to `ExposomeSet`

To coerce the three tables that make the exposome dataset into an `ExposomeSet` R object, the tables have to be loaded inside the same study server. On this example, the tables are on the demo Opal server as resources, which means they have to be loaded on the study server and be coerced as data frames; for more information read the [resourcer](https://cran.r-project.org/web/packages/resourcer/index.html) package documentation. 

```{r}
library(dsBaseClient)
library(dsExposomeClient)
library(DSOpal)

builder <- newDSLoginBuilder()
builder$append(server = "server1", url = "https://opal-demo.obiba.org/",
               user = "administrator", password = "password",
               driver = "OpalDriver")
logindata <- builder$build()
conns <- datashield.login(logins = logindata)

datashield.assign.resource(conns, symbol = 'description', resource = list(server1 = 'EXPOSOME.description'))
ds.class('description')
datashield.assign.expr(conns, symbol = "description", expr = quote(as.resource.data.frame(description)))
ds.class('description')

datashield.assign.resource(conns, symbol = 'exposures', resource = list(server1 = 'EXPOSOME.exposures'))
datashield.assign.expr(conns, symbol = "exposures", expr = quote(as.resource.data.frame(exposures)))

datashield.assign.resource(conns, symbol = 'phenotypes', resource = list(server1 = 'EXPOSOME.phenotypes'))
datashield.assign.expr(conns, symbol = "phenotypes", expr = quote(as.resource.data.frame(phenotypes)))

ds.ls()
```

If the tables are on the Opal server as tables instead of resources, the lines after the `datashield.login` would look like this

```{r eval = FALSE}
# Don't run this code, the tables are not on the demo Opal server, it's just for demostration purposes
datashield.assign.table(conns, symbol = 'description', table = list(server1 = 'EXPOSOME.description_table'))

  # Repeat for the other two tables
```

When there are tables on the Opal server they can be directly loaded to the study server as data frames, there is no need to perform the `as.data.frame` assignation.

To coerce the three tables to the `ExposomeSet` object, the `dsExposomeClient` library has the `ds.loadExposome()` function, which takes as input parameters the names of the tables on the study server among some further configuration options, refer to the function documentation for more information.

```{r}
ds.loadExposome("exposures", "description", "phenotypes", "idnum", "idnum", "Exposure", "Family", 5, FALSE, "exposome_object")
ds.class("exposome_object")
```

### From resource to `ExposomeSet`

When there's an `ExposomeSet` resource available, it just needs to be loaded into the study server

```{r}
datashield.assign.resource(conns, symbol = 'exposome_resource', resource = list(server1 = 'EXPOSOME.exposomeSet'))

ds.ls()
ds.class("exposome_resource")
```

Once on the study server, the resource has to be coerced into an R object

```{r}
datashield.assign.expr(conns, symbol = "exposome_resource", expr = quote(as.resource.object(exposome_resource)))
ds.class("exposome_resource")
```

## Exploring the loaded dataset

Once the Exposome datasets are loaded on the study servers, some simple functions can be used to have some understanding of what the dataset contains. Those correspond to the name of the exposures, the names of the families of the exposures and the name of the phenotypes.

### Family names

To get the names of the families of exposures present on the exposome set, there's the `ds.familyNames` function, it can take the parameter `by.exposure = TRUE` to list the family names and the exposures that contain each family.

```{r}
ds.familyNames("exposome_object")
head(ds.familyNames("exposome_object", TRUE)$server1)
```

### Exposures and phenotypes names

To get the names of the exposures or phenotypes (or both combined) there's the function `ds.exposome_variables`, it takes as argument `exposures`, `phenotypes` or `all` to retrieve the desired names.

```{r}
head(ds.exposome_variables("exposome_object" , "exposures", conns)$server1)
ds.exposome_variables("exposome_object" , "phenotypes", conns)
```




### Summary of variables

Non-disclosive descriptive statistics can be obtained from the exposome dataset, the function `ds.exposome_summary` is in charge of that. It can obtain descriptive statistics from numeric and factor variables of the exposome dataset (both from exposures and phenotypes). 

```{r}
# Numerical variable
ds.exposome_summary("exposome_object", "PM25", conns)
# Factor variable
ds.exposome_summary("exposome_object", "flu", conns)
```

### Missing data

The number of missing data on each exposure and on each phenotype can be found by using the function `ds.tableMissings`. This function returns a vector with the amount of missing data in each exposure or phenotype. The argument `set` indicates if the number of missing values is counted on exposures or phenotypes. The argument `output` indicates if it is shown as counts (`output="n"`) or as percentage (`output="p"`).

```{r}
ds.tableMissings("exposome_object", set = "exposures")
ds.tableMissings("exposome_object", set = "phenotypes")
```

Optionally, there's also the `ds.plotMissings` function which returns a `ggplot` object with a barplot of missings for exposures or phenotypes, there's the option of displaying the percentage of missings as well as total counts, check the function documentation for further information.

```{r}
ds.plotMissings("exposome_object", "exposures", "p")
```

Please note that since this function call returns a `ggplot` object, it can be plotted properly to avoid squished Y axis when there are lots of exposures, read the [official documentation](https://ggplot2.tidyverse.org/reference/ggsave.html) for information on how to do that.

### Exposures Normality

Most of the test done in *exposome* analysis requires that the exposures must follow a normal distribution. The function `ds.normalityTest` performs a test on each exposure for normality behaviour. The result is a `data.frame` with the exposures’ names, a flag `TRUE`/`FALSE` for normality and the p-value obtained from the *Shapiro-Wilk* Normality Test (if the p-value is under the threshold, then the exposure is not normal).

```{r}
nm <- ds.normalityTest("exposome_object")
table(nm$server1$normality)
```

So, the exposures that do not follow a normal distribution are:

```{r}
nm$server1$exposure[!nm$server1$normality]
```

The `ds.normalityTest` function has some extra input arguments to tune the normality test, check the function documentation for further information.

The exposures can be visualized using non-disclosive histograms to see their distribution.

```{r results = FALSE}
ds.exposure_histogram("exposome_object", "BDE209")
```

If the selected exposure is not following a normal distribution, the function `ds.exposure_histogram` accepts the argument `show.trans` to visualize the raw data histogram plus three typical transformations (`exp`, `log` and `sqrt`).

```{r results = FALSE}
ds.exposure_histogram("exposome_object", "BDE209", TRUE)
```

### Exposures Behaviour

We can get a snapshot of the behaviour of the full exposome using the `ds.plotFamily` fuction. This function draws a mosaic of boxplots with all the numeric families of exposures, it can also plot single families and perform grouping inside of them. This function makes use of the `gplot2` library to generate the plots, the plot objects that generates this library have a disadvantage for the goal of DataSHIELD, which is that they contain the dataset used to produce the plot, for that reason the dataset is passed thorugh the `scatterDS` function of `dsBase`, by doing so the data is protected and the actual `ggplot` object contains the same information that would be found when trying to plot a Scatter plot of a variable against itself. Since this process can't be applied to a factor variable, they can't be plotted using this function, as it would disclose the values of it.

```{r}
ds.plotFamily("exposome_object", family = "all", method = 1, k = 4, noise = 0.25)
ds.plotFamily("exposome_object", family = "Phthalates", group = "sex", method = 1, k = 4, noise = 0.25)
ds.plotFamily("exposome_object", family = "Phthalates", group = "sex", group2 = "rhinitis", method = 1, k = 4, noise = 0.25)
```


## Exposures Imputation

The missings of an exposome dataset can be imputed using the `ds.imputation` function, which calls the rexposome function `imputation` on the study server. Refer to the documentation of rexposome for details about the imputation procedures.

```{r}
ds.imputation("exposome_object", "exposome_object_imputed")
```


## Performing an ExWAS

When the `ExposomeSet` object is on the study the server, the function `ds.exwas` is in charge of performing the ExWAS. As an example let's present a situation where each exposition has to be associated to the `blood_pre` phenotype using the phenotype `sex` as a covariate. This study would be done as follows

```{r}
exwas_results <- ds.exwas("blood_pre ~ sex", "exposome_object", "gaussian", FALSE, conns)
head(exwas_results$exwas_results)
```

The model is inputed as a string, where the left side term is the objective phenotype, and the right term are the covariates, in the case of wanting more covariates proceed as: `objective ~ cov1 + cov2 + ... + covN`. It's important noting that if the output family (third argument) does not match the objective family, the ExWAS will fail (Example: The objective family is `binomial` and the user sets it to `gaussian`).

## Exposures PCA

A PCA can be performed on the exposures of the exposome dataset. To do so, there's the `ds.exposome_pca`. The function offers the functionality of standarizing the input data with the argument `standar`. It is important noting that this function is sensitive to be disclosive, specially for very rectangular data frames (similar number of variables as individuals). To illustrate this problem, let's try to perform a PCA on the whole exposures test data.

```{r error = TRUE}
ds.exposome_pca("exposome_object", TRUE)
```

If that is the case, one option is to reduce the families of exposures of the Exposome Set. There's an already subsetted Exposome Set object available on the `test_data` folder of `dsExposomeClient` for demostration purposes.

```{r}
datashield.assign.resource(conns, symbol = 'exposome_pca', resource = list(server1 = 'EXPOSOME.exposomeSet_PCA'))
datashield.assign.expr(conns, symbol = "exposome_pca", expr = quote(as.resource.object(exposome_pca)))

pca <- ds.exposome_pca("exposome_pca")
head(pca[,1:4])
```

```{r}
datashield.logout(conns)
```

